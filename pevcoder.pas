unit pevcoder;

(*************************************************************************

PEVRICA COMPRESSION ALGORITHM

Algorithm is educational, non-standart, fully made by me.

Low-compression, very fast and simple algorithm

Uses two tiny dictionaries

One is COMPRESS type (64 bytes), 8 to 7 bits
Second is NULL type (32 bytes), 8 to 8 bits

Dictionaries are generated by analising and sorting data statistics.

Other data is enlarged to 10 bits;

(c)  2009 Alexander Myasnikow

Russia, Vladimir region, Kolchugino

WEB: www.darksoftware.narod.ru

E-mail: darksoftware@ya.ru

Free for non-commercial usage

If you like this code and want to use it

in commercial software, please contact author.

*************************************************************************)


interface


uses Classes, Windows, SysUtils, Math;

type
  TPevCoder = class

  type
    TBitA = array of byte;
  var
    BitA:    TBitA;
    BitAPos: integer;

  const
    header: word = $FEAD;   

    procedure LoadToBA (fn: string);
    procedure SaveToBA (fn: string);
    procedure SavePacked (fn: string);
    procedure LoadPacked (fn: string);
    function GetBit: byte;
    procedure PutBit (b: byte);
    procedure PutByte (b: byte);
    procedure PutInteger (b: longint);
    procedure PutWord (b: word);
    function GetByte (): byte;
    function GetInteger (): longint;
    function GetWord (): word;
    function GetFileSize (FileName: string): integer;
    function MakeSum (a, b: byte): byte;

    procedure makestats (fn: string);
    procedure SortStats;
    function GetLastMax: byte;
    function findcompress (d: byte): integer;
    function findnull (d: byte): integer;

    constructor Create;
    destructor Destroy; override;

  var
    COMPRESS: array [0..63] of byte;
    NULL:     array [0..31] of byte;
    STAT:     array [0..255] of longint;
    STAT_T:   array [0..255] of longint;
  end;

implementation

uses bfs, pevfrm;

function TPevCoder.GetLastMax: byte;
  var
    i, m: integer;
  begin
    m := 0;

    for i := 0 to 255 do
      begin
      if STAT[i] > m then
        begin
        m := STAT[i];
        Result := i;
        end;
      end;

    STAT[Result] := -1;

  end;

procedure TPevCoder.SortStats;
  var
    i, n: integer;
  begin

    for I := 0 to 255 do
      begin
      STAT_T[i] := 0;
      end;

    for I := 0 to 255 do
      begin
      STAT_T[i] := GetLastMax;
      end;

    n := 0;

    for I := 0 to 63 do
      begin
      Compress[i] := STAT_T[n];
      Inc(n);
      end;

    for I := 0 to 31 do
      begin
      Null[i] := STAT_T[n];
      Inc(n);
      end;

  end;


procedure TPevCoder.makestats (fn: string);
  var
    i:  integer;
    FS: TBFileStream;
    b:  byte;
  begin

    for I := 0 to 255 do
      STAT[i] := 0;

    FS := TBFileStream.Create(fn, fmOpenRead);

    for I := 0 to FS.Size - 1 do
      begin

      FS.Read(b, 1);

      Stat[b] := Stat[b] + 1;

      end;

    FS.Free;

  end;

constructor TPevCoder.Create;
  begin
    BitAPos := 0;
  end;


destructor TPevCoder.Destroy;
  begin
    SetLength(BitA, 0);
    inherited Destroy;
  end;


function TPevCoder.GetBit: byte;
  begin
    if BitAPos < Length(BitA) then
      begin
      Result  := BitA[BitAPos];
      BitAPos := BitAPos + 1;
      end
    else
      begin
      Result := random(256) and 1;
      end;
  end;

procedure TPevCoder.PutBit (b: byte);
  begin
    if (Length(BitA) - BitAPos) < 32768 then
      SetLength(BitA, Length(BitA) + 32768);

    BitA[BitAPos] := b;
    BitAPos := BitAPos + 1;

  end;


procedure TPevCoder.PutByte (b: byte);
  var
    n: integer;
  begin

    for n := 0 to 7 do
      begin
      BitA[BitAPos] := (b shr n) and 1;
      Inc(BitAPos);
      end;
  end;


procedure TPevCoder.PutInteger (b: longint);
  var
    n: integer;
  begin

    for n := 0 to 31 do
      begin
      BitA[BitAPos] := (b shr n) and 1;
      Inc(BitAPos);
      end;
  end;


procedure TPevCoder.PutWord (b: word);
  var
    n: integer;
  begin

    for n := 0 to 15 do
      begin
      BitA[BitAPos] := (b shr n) and 1;
      Inc(BitAPos);
      end;
  end;


function TPevCoder.GetByte (): byte;
  var
    n: integer;
  begin

    Result := 0;

    BitAPos := BitAPos + 8;

    for n := 1 to 8 do
      begin
      Result := Result shl 1 + BitA[BitAPos - n];
      end;

  end;

function TPevCoder.GetInteger (): longint;
  var
    n: integer;
  begin

    Result := 0;

    BitAPos := BitAPos + 32;

    for n := 1 to 32 do
      begin
      Result := Result shl 1 + BitA[BitAPos - n];
      end;

  end;


function TPevCoder.GetWord (): word;
  var
    n: integer;
  begin

    Result := 0;

    BitAPos := BitAPos + 16;

    for n := 1 to 16 do
      begin
      Result := Result shl 1 + BitA[BitAPos - n];
      end;

  end;


function TPevCoder.MakeSum (a: byte; b: byte): byte;
  begin
    Result := a + b;
  end;


function TPevCoder.findcompress (d: byte): integer;
  var
    i: integer;
  begin
    Result := -1;
    for I := 0 to 63 do
      begin

      if compress[i] = d then
        begin
        Result := i;
        break;
        end;

      end;

  end;

function TPevCoder.findnull (d: byte): integer;
  var
    i: integer;
  begin
    Result := -1;
    for I := 0 to 31 do
      begin

      if null[i] = d then
        begin
        Result := i;
        break;
        end;

      end;

  end;


procedure TPevCoder.LoadToBA (fn: string);
  var
    FS: TBFileStream;
  var
    i, n: integer;
    d:  byte;
    f:  integer;
    notfound: boolean;

  begin

    makestats(fn);
    sortstats;

    FS := TBFileStream.Create(fn, fmOpenRead);
    SetLength(BitA, fs.Size * 8 + 48 + 16 + fs.Size);
    BitAPos := 0;
    PutWord(Header);
    PutInteger(fs.Size);

    for I := 0 to 63 do
      PutByte(Compress[i]);

    for I := 0 to 31 do
      PutByte(Null[i]);

    for I := 1 to FS.Size do
      begin

      notfound := True;

      FS.Read(d, 1);

      f := findcompress(d);

      if f <> -1 then

        begin

        notfound := False;

        PutBit(1);
        for n := 0 to 5 do
          PutBit(f shr n and 1);
        end;


      if notfound then
        begin

        f := findnull(d);

        if f <> -1 then

          begin

          notfound := False;

          PutBit(0);
          PutBit(1);
          for n := 0 to 4 do
            PutBit(f shr n and 1);
          end;
        end;


      if notfound then

        begin
        PutBit(0);
        PutBit(0);
        PutByte(d);
        end;

      end;


    FS.Free;
  end;


procedure TPevCoder.SaveToBA (fn: string);
  var
    FS: TBFileStream;
    i, size, done, n: integer;
    d:  byte;
    bits: array [0..5] of byte;

  begin
    FS := TBFileStream.Create(fn, fmCreate);
    BitAPos := 16;
    size := GetInteger;

    for I := 0 to 63 do
      Compress[i] := GetByte();

    for I := 0 to 31 do
      Null[i] := GetByte();


    done := 0;
    while True do
      begin
      case GetBit() of
        0:
          begin
          if GetBit() = 0 then
            begin
            d := GetByte();
            end
          else
            begin
            d := 0;
            for n := 4 downto 0 do
              begin
              bits[n] := GetBit();
              end;

            for n := 0 to 4 do
              begin
              d := d shl 1 + Bits[n];
              end;
            d := NULL[d];

            end;
          end;
        1:
          begin

          d := 0;
          for n := 5 downto 0 do
            begin
            bits[n] := GetBit();
            end;

          for n := 0 to 5 do
            begin
            d := d shl 1 + Bits[n];
            end;
          d := COMPRESS[d];

          end

        end;

      FS.Write(d, 1);
      Inc(done, 1);
      if done > size then
        break;
      end;

    FS.SetSize(Size);
    FS.Free;
  end;

procedure TPevCoder.SavePacked (fn: string);
  var
    FS: TBFileStream;
    size: integer;
    b:  byte;
    i:  integer;
  begin
    size := Ceil(bitapos / 8);
    BitAPos := 0;
    FS := TBFileStream.Create(fn, fmCreate);
    for I := 0 to size - 1 do
      begin
      b := getbyte;
      FS.Write(b, 1);
      end;
    FS.Free;
  end;

function TPevCoder.GetFileSize (FileName: string): integer;
  var
    FS: TBFileStream;
  begin
      try
      FS := TBFileStream.Create(Filename, fmOpenRead);
      except
      Result := -1;
      end;
    if Result <> -1 then
      Result := FS.Size;
    FS.Free;
  end;

procedure TPevCoder.LoadPacked (fn: string);
  var
    FS: TBFileStream;
    fsize, i: integer;
    b:  byte;
  begin
    BitAPos := 0;
    fsize := GetFileSize(fn);
    FS := TBFileStream.Create(fn, fmOpenRead);
    SetLength(BitA, fsize * 8);
    for I := 0 to Fsize - 1 do
      begin
      FS.Read(b, 1);
      PutByte(b);
      end;
    FS.Free;
  end;


initialization
  randomize();

end.
